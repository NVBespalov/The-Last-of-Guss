# 11. Проектирование (System Design)

## 11.1 Архитектурные решения

### Структура Backend

- **Выбор между монолитной и микросервисной архитектурой:**
    - На начальном этапе допустим монолит с возможностью выноса отдельных модулей (доменов) в микросервисы по мере роста проекта и увеличения требований к масштабируемости.
    - Проектировать backend рекомендуется уже с учетом возможного разделения на сервисы (чёткая модульность, использование интерфейсов, продуманная точка входа, стандартизация API).
    - Все сервисы должны быть готовы к горизонтальному масштабированию и использованию распределённых инструментов аутентификации, логирования, мониторинга.

### Технологический стек

**Backend:**
- Язык: **TypeScript** (обязательно strict mode)
- Платформа: **Node.js**
- ORM/DB access: **Prisma** (рекомендуется для строгой типизации, автоматизации миграций и удобной работы с Postgres)
- СУБД: **PostgreSQL**
- API Framework: **NestJS** (структурированный подход, поддержка масштабируемых архитектур, тестируемость, готовые решения для DI и модульности)
- Мониторинг: **Prometheus** + [экспортеры](https://prometheus.io/docs/instrumenting/exporters/)
- Контейнеризация: **Docker**
- Тестирование: **Jest** (юнит), **Supertest** (интеграция)

**Frontend:**
- Фреймворк: **React**
- Язык: **TypeScript**
- Сборщик: **Vite**
- Роутинг: **react-router**
- UI-библиотека: **MUI** (или иная выбранная, в документации зафиксировать окончательный выбор)
- State manager: **Redux Toolkit** или **Zustand** (выбирать и зафиксировать в документации)
- Формы: **React Hook Form**
- Тестирование: **Jest**, **React Testing Library** (юниты); **Cypress** (e2e, интеграция)
- Docker-контейнер для автосборки и деплоя

---

## 11.2 Стандарты обмена данными

- Основной транспорт: **REST API** (опционально GraphQL/SSR при необходимости)
- Формат: **JSON**
- Обработка ошибок: стандартизированная структура ответа для ошибок

---

## 11.3 Прочее

- Версии и состав библиотек фиксировать в package.json с использованием зависимостей в диапазоне minor-версий (например, ^6.0.0).
- Согласовывать все ключевые изменения в архитектуре через команду/архитектора.
- Документировать интеграционные точки, маппинг моделей и внешние зависимости.
- Организовать CI/CD-конвейер (Docker, линтеры, тесты) для проверки каждого pull request.
